#!/bin/bash

set -x
set -u
set -e

# Environment is used as the cluster name
ENVIRONMENT=${ENVIRONMENT}
HOW_MANY_INSTANCES=${HOW_MANY_INSTANCES}
LOAD_BALANCER_NAME=${LOAD_BALANCER_NAME}
CONTAINER_NAME=${CONTAINER_NAME}
CONTAINER_PORT=${CONTAINER_PORT}
IMAGE_TAG=${IMAGE_TAG}

# This is temporary
serviceExists="true"

AWS_ROLE=ecsServiceRole
ECS_COMPOSE_FILENAME=ecs-compose.yml

echo "Creating a task definition"
TASK_DEFINITION_RESPONSE_FILE=/tmp/task-definition-output.txt

ORIGINAL_FILE=${ECS_COMPOSE_FILENAME}
NEW_FILE=/tmp/ecs-compose-processed.yml

echo "Deploying file ${ECS_COMPOSE_FILENAME} with content:"
cat ${ORIGINAL_FILE}

sed 's/@@IMAGE_TAG@@/${IMAGE_TAG}/g' ${ORIGINAL_FILE} > ${NEW_FILE}

touch $TASK_DEFINITION_RESPONSE_FILE
ecs-cli compose --file ${NEW_FILE} --project-name ${PROJECT_NAME} create

# We have to do this because for some reason we can't parse the ecs-cli compose response
function getLatestTaskDefinitionRevision() {
  project_name=$1
  revision=$(aws ecs list-task-definitions | grep ecscompose-${project_name}: | sed 's|^.*/ecscompose-||' | sed 's|.*:||' | sed 's|\"||' | sed 's|,||' | sort -nr | head -n1)
  echo $revision
}

SERVICE_NAME="ecscompose-service-${PROJECT_NAME}"
TASK_DEFINITION_NAME="ecscompose-simple-node-app:$(getLatestTaskDefinitionRevision ${PROJECT_NAME})"

if [ "${serviceExists}" = "true" ]; then
    aws ecs update-service --service "${SERVICE_NAME}" --task-definition "${TASK_DEFINITION_NAME}"
else
    aws ecs create-service --service-name "${SERVICE_NAME}" --cluster "${ENVIRONMENT}" --task-definition "$TASK_DEFINITION_NAME" --load-balancers "loadBalancerName=${LOAD_BALANCER_NAME},containerName=${CONTAINER_NAME},containerPort=${CONTAINER_PORT}" --desired-count ${HOW_MANY_INSTANCES} --deployment-configuration "maximumPercent=200,minimumHealthyPercent=50" --role ${AWS_ROLE}
fi
